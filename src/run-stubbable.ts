import { readFileSync, writeFileSync } from 'fs';
import * as vscode from 'vscode';
import { InputBoxExecution } from './input-box';
import { replacer, reviver } from './workspace-configuration';

// STUBBABLE_TEST_FILE_PATH is the path to the file to which stubbable data is written.
// This is needed to communicate data between the test code and the separate extension executable
// that is generated by the vscode-test-cli.
const STUBBABLE_TEST_FILE_PATH = process.env.VSCODE_STUBBABLE_TEST_FILE;

// TEST_MODE is whether or not the
export const TEST_MODE: boolean = !!STUBBABLE_TEST_FILE_PATH;

// StubbablesConfig is the VS Code configuration defined on a per-test basis.
export interface StubbablesConfig {
  /**
   * The expected set of info messages to be displayed.
   */
  expectedInfoMessages?: string[];

  /**
   * The expected set of error messages to be displayed.
   */
  expectedErrorMessages?: string[];

  /**
   * The input box responses to return.
   */
  inputBoxResponses?: (string | undefined)[];

  /**
   * The expected input box executions.
   */
  expectedInputBoxes?: InputBoxExecution[];
}

// StubbablesConfigInternal is an internal model used for storing additional fields required for testing.
// IMPORTANT NOTE: Only fields for stubbed methods should be added here
// Everything else should be added to verify.testData.
export interface StubbablesConfigInternal extends StubbablesConfig {
  // If there is any error in stubbables configuration internal logic, it is set here.
  error?: string;

  // If the data needs to be reloaded
  loaded?: boolean;
}

export function updateConfig(sc: StubbablesConfigInternal) {
  try {
    writeFileSync(STUBBABLE_TEST_FILE_PATH!, JSONStringify(sc));
  } catch (e) {
    const msg = `Failed to write stubbables config back test file: ${e}`;
    console.log(msg);
    vscode.window.showErrorMessage(msg);
  }
}

export function runStubbableMethodNoInput<O>(nonTestLogic: () => O, testLogic: (config: StubbablesConfigInternal) => O): () => O {
  return runStubbableMethodTwoArgs<void, void, O>(
    () => nonTestLogic(),
    (input1: void, input2: void, sc: StubbablesConfigInternal) => testLogic(sc),
  );
}

export function runStubbableMethod<I, O>(nonTestLogic: (input: I) => O, testLogic: (input: I, config: StubbablesConfigInternal) => O): (input: I) => O {
  return runStubbableMethodTwoArgs<I, void, O>(
    nonTestLogic,
    (input1: I, input2: void, sc: StubbablesConfigInternal) => testLogic(input1, sc),
  );
}

// TODO: Remove this?
let globalStubbableConfig: StubbablesConfigInternal = {};

export function runStubbableMethodTwoArgs<I1, I2, O>(nonTestLogic: (input1: I1, input2: I2) => O, testLogic: (input1: I1, input2: I2, config: StubbablesConfigInternal) => O): (input1: I1, input2: I2) => O {
  return (input1: I1, input2: I2) => {
    if (!STUBBABLE_TEST_FILE_PATH) {
      return nonTestLogic(input1, input2);
    }

    try {
      const newStubbableConfig: StubbablesConfigInternal = JSONParse(readFileSync(STUBBABLE_TEST_FILE_PATH).toString());
      // If not already loaded, then starting a new test
      if (!newStubbableConfig.loaded) {
        // TODO: Add test for this (if nested, stubbable writes, then an issue, e.g. update configuration inside of quick pick)
        globalStubbableConfig = newStubbableConfig;
        globalStubbableConfig.loaded = true;
        updateConfig(globalStubbableConfig);
      }
    } catch (e) {
      vscode.window.showErrorMessage(`Failed to read/parse stubbables test file: ${e}`);
      return nonTestLogic(input1, input2);
    }

    return testLogic(input1, input2, globalStubbableConfig);
  };
}

export function JSONParse(text: string) {
  return JSON.parse(text, reviver);
}

export function JSONStringify(obj: any) {
  return JSON.stringify(obj, replacer, 2);
}
